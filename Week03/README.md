学习笔记

# Go的并发编程

## 重要的事情
      
      1. 是不是要go出去交给调用者
      2. 管控这个goroutine的生命周期
      3. 控制goroutine退出
`
## SELECT语句
    select语句会一直阻塞，直到某一个case可以运行，然后运行这个case.如果多个case同时ready，会随机选择一个执行
    
## DEFER、PANIC
    defer当一个方法执行结束时会自动调用的
## 通过通信共享内存
Go鼓励一种不同的方式，这种方式通过在通道传递来共享数据。并且，永远不会通过单独执行的线程来主动共享。在给定的时间内，只有一个goroutine可以访问值。在设计上，数据竞争就不会发生。有一句口号是：不要通过共享内存来通信，相反的，应该通过通信来共享内存。

## Goroutine
Goroutine有一个简单的模型：在同一片内存空间中，和其他的goroutines同时执行的函数。它非常轻量，只比分配堆栈空间多一点。
Goroutine是在系统线程的多路复用，所以，如果其中一个阻塞，比如等待I/O，其他的可以继续执行。它们的设计隐藏了线程创建和管理的很多复杂性。
在函数调用前使用go关键字就可以启动一个新的goroutine，当调用结束，goroutines就会默默的退出，类似于Linux的后台运行符号&。
在启动goroutine外面用函数包一下在go里面很实用，因为函数闭包的特性，可以使引用的变量只在他们运行的时候有效。


## 通道
通过make关键字来分配，返回值是对底层数据结构的引用
   
   |        | 声明 | 区别 |
   |  ----  | ----  | ---- |
   | 无缓冲通道  | make(chan int) 或者 make(chan int 0) |发送者和接收者在接收者取回数据前，都是阻塞状态|
   | 有缓冲通道  | make(chan int 10) |接收者在没取到数据时是阻塞的，但是发送者只会当数据还没复制到缓冲区的时候是阻塞的，比如：如果缓冲区已满，则发送者不能把数据放到缓冲区，则发送者就会阻塞，直到有接收者取出数据，腾出空间，发送者把数据复制到缓冲区|

（有缓冲通道：限制最多同时处理的量，可以用来削峰）

## 通道的通道
Go最重要的特性之一就是通道是"一等公民"，它可以像其他类型的值一样，被分配和被传递。

## 并行
最重要的是并发!=并行。
并发：将程序构造为独立运行的组件
并行：在多核计算机上并行的执行计算来提高效率


# 内存模型
启动一个新的goroutine的go语句要比goroutine的执行先行发生。
但是goroutine的退出并不一定比程序的其他任何时间先行发生。
如果一个goroutine的影响必须要被其他goroutine所感知，就需要使用同步原语（比如锁、通道通信）来建立一个相对的顺序。


## 通道通信
通道通信是goroutine之间同步化的主要方法。
无缓冲通道：数据接受后，发送者才算完成

## 锁


## Once



















## happens before 先行发生
在单个goroutine中，读取和写入必须表现的像它们在程序中指定的顺序执行那样。也就是说，只有当重新排序不会改变被语言规范所定义的那个goroutine的行为时，编译器和处理器才能重新排序在一个goroutine中的读取和写入的执行顺序。因为重新排序，被一个goroutine观察到的执行顺序有可能和另外一个所感知的执行顺序不一样。举个例子：一个goroutine执行顺序a=1,b=2，另一个goroutine观察到的是先更新b的值，再更新a的值。


为了指定读写要求，我们定义：先行发生，是在go程序中，内存操作的部分执行顺序。如果事件e1先于事件e2发生，也可以说事件e2后于事件e1发生。如果e1不会先于e2发生，也不会后于e2发生，我们就说e1和e2同时发生（并发）。


在单个的goroutine中，先行发生顺序就是程序所表达的顺序。


读变量v的事件r,只有当变量v的写事件同时满足下面两个条件是才被允许：
1. r事件后于w事件
2. w事件执行后，r事件执行前，没有其他的写操作




